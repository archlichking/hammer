// Code generated by protoc-gen-go.
// source: src/eReceipts_server_service/RService.proto
// DO NOT EDIT!

/*
Package eReceipts_server_service is a generated protocol buffer package.

It is generated from these files:
	src/eReceipts_server_service/RService.proto

It has these top-level messages:
	CommsConfig
	KeyValue
	SimplifiedReturns
	ISPItem
	ReceiptLine
	GiftReceipt
	ISPReceipt
	UploadReceiptRequest
	UploadReceiptResponse
	ReceiptItem
	ReceiptForReturn
	StoredReceipt
	CustomerReceiptsRequest
	CustomerReceiptsResponse
	ReceiptForReturnRequest
	ReceiptForReturnResponse
	ReceiptHistoryRequest
	ReceiptHistoryResponse
	OneHourGuaranteeVirtualItem
	OneHourGuaranteeGiftCard
	OneHourGuaranteeLookup
	OneHourGuaranteeLookupRequest
	OneHourGuaranteeLookupResponse
	TemplateImage
	TemplatesConfigDefault
	TemplatesConfigOverride
	SyncTemplatesRequest
	SyncTemplatesResponse
	CardReaderAttribute
	CardReaderProfile
	RefreshCardReaderProfilesRequest
	RefreshCardReaderProfilesResponse
	ProcessStatus
	HeartbeatRequest
	HeartbeatResponse
	UploadLogsRequest
	UploadLogsResponse
	LookupCustomerRequest
	LookupCustomerResponse
	TrxVoidedRequest
	TrxVoidedResponse
	StaticImageDataRequest
	StaticImageDataResponse
	VuduMarketingReceiptLine
	VuduRedeemableProduct
	RefreshVuduMarketingRequest
	MarketingImage
	RefreshVuduMarketingResponse
	SiteToStoreCheckinRequest
	SiteToStoreCheckinResponse
*/
package eReceipts_server_service

import proto "code.google.com/p/goprotobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type CommsConfig_OperationMode int32

const (
	// ! Send all receipts
	CommsConfig_NORMAL CommsConfig_OperationMode = 1
	// ! Send only MSCO receipts
	CommsConfig_MSCO_ONLY CommsConfig_OperationMode = 2
	// ! Don't send any receipts
	CommsConfig_OFF CommsConfig_OperationMode = 3
	// ! Send all MSCO receipts and every 2nd non-msco receipt
	CommsConfig_ALL_MSCO_AND_EVERY_2ND_OTHER CommsConfig_OperationMode = 4
	// ! Send all MSCO receipts and every 10th non-msco receipt
	CommsConfig_ALL_MSCO_AND_EVERY_10TH_OTHER CommsConfig_OperationMode = 5
	// ! Send all MSCO receipts and every 30th non-msco receipt
	CommsConfig_ALL_MSCO_AND_EVERY_30TH_OTHER CommsConfig_OperationMode = 6
)

var CommsConfig_OperationMode_name = map[int32]string{
	1: "NORMAL",
	2: "MSCO_ONLY",
	3: "OFF",
	4: "ALL_MSCO_AND_EVERY_2ND_OTHER",
	5: "ALL_MSCO_AND_EVERY_10TH_OTHER",
	6: "ALL_MSCO_AND_EVERY_30TH_OTHER",
}
var CommsConfig_OperationMode_value = map[string]int32{
	"NORMAL":    1,
	"MSCO_ONLY": 2,
	"OFF":       3,
	"ALL_MSCO_AND_EVERY_2ND_OTHER":  4,
	"ALL_MSCO_AND_EVERY_10TH_OTHER": 5,
	"ALL_MSCO_AND_EVERY_30TH_OTHER": 6,
}

func (x CommsConfig_OperationMode) Enum() *CommsConfig_OperationMode {
	p := new(CommsConfig_OperationMode)
	*p = x
	return p
}
func (x CommsConfig_OperationMode) String() string {
	return proto.EnumName(CommsConfig_OperationMode_name, int32(x))
}
func (x *CommsConfig_OperationMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CommsConfig_OperationMode_value, data, "CommsConfig_OperationMode")
	if err != nil {
		return err
	}
	*x = CommsConfig_OperationMode(value)
	return nil
}

// ! If we aren't "HEALTHY" we are in trouble
type ProcessStatus_HealthStatus int32

const (
	ProcessStatus_UNKNOWN                 ProcessStatus_HealthStatus = 1
	ProcessStatus_HEALTHY                 ProcessStatus_HealthStatus = 2
	ProcessStatus_DB_NOT_EXIST            ProcessStatus_HealthStatus = 3
	ProcessStatus_FAILED_OPEN_DB          ProcessStatus_HealthStatus = 4
	ProcessStatus_DISCONNECTED_DISPATCH   ProcessStatus_HealthStatus = 5
	ProcessStatus_FAILED_CONNECT_DISPATCH ProcessStatus_HealthStatus = 6
	ProcessStatus_FAILED_SET_BUSY_TIMEOUT ProcessStatus_HealthStatus = 7
	ProcessStatus_NOT_RUNNING             ProcessStatus_HealthStatus = 8
)

var ProcessStatus_HealthStatus_name = map[int32]string{
	1: "UNKNOWN",
	2: "HEALTHY",
	3: "DB_NOT_EXIST",
	4: "FAILED_OPEN_DB",
	5: "DISCONNECTED_DISPATCH",
	6: "FAILED_CONNECT_DISPATCH",
	7: "FAILED_SET_BUSY_TIMEOUT",
	8: "NOT_RUNNING",
}
var ProcessStatus_HealthStatus_value = map[string]int32{
	"UNKNOWN":                 1,
	"HEALTHY":                 2,
	"DB_NOT_EXIST":            3,
	"FAILED_OPEN_DB":          4,
	"DISCONNECTED_DISPATCH":   5,
	"FAILED_CONNECT_DISPATCH": 6,
	"FAILED_SET_BUSY_TIMEOUT": 7,
	"NOT_RUNNING":             8,
}

func (x ProcessStatus_HealthStatus) Enum() *ProcessStatus_HealthStatus {
	p := new(ProcessStatus_HealthStatus)
	*p = x
	return p
}
func (x ProcessStatus_HealthStatus) String() string {
	return proto.EnumName(ProcessStatus_HealthStatus_name, int32(x))
}
func (x *ProcessStatus_HealthStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ProcessStatus_HealthStatus_value, data, "ProcessStatus_HealthStatus")
	if err != nil {
		return err
	}
	*x = ProcessStatus_HealthStatus(value)
	return nil
}

type LookupCustomerResponse_ReceiptBehaviour int32

const (
	LookupCustomerResponse_CUSTOMER_IDENTITY_NOT_FOUND       LookupCustomerResponse_ReceiptBehaviour = 1
	LookupCustomerResponse_CUSTOMER_WANTS_PAPER_AND_ERECEIPT LookupCustomerResponse_ReceiptBehaviour = 2
	LookupCustomerResponse_STUB_RECEIPT                      LookupCustomerResponse_ReceiptBehaviour = 3
)

var LookupCustomerResponse_ReceiptBehaviour_name = map[int32]string{
	1: "CUSTOMER_IDENTITY_NOT_FOUND",
	2: "CUSTOMER_WANTS_PAPER_AND_ERECEIPT",
	3: "STUB_RECEIPT",
}
var LookupCustomerResponse_ReceiptBehaviour_value = map[string]int32{
	"CUSTOMER_IDENTITY_NOT_FOUND":       1,
	"CUSTOMER_WANTS_PAPER_AND_ERECEIPT": 2,
	"STUB_RECEIPT":                      3,
}

func (x LookupCustomerResponse_ReceiptBehaviour) Enum() *LookupCustomerResponse_ReceiptBehaviour {
	p := new(LookupCustomerResponse_ReceiptBehaviour)
	*p = x
	return p
}
func (x LookupCustomerResponse_ReceiptBehaviour) String() string {
	return proto.EnumName(LookupCustomerResponse_ReceiptBehaviour_name, int32(x))
}
func (x *LookupCustomerResponse_ReceiptBehaviour) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LookupCustomerResponse_ReceiptBehaviour_value, data, "LookupCustomerResponse_ReceiptBehaviour")
	if err != nil {
		return err
	}
	*x = LookupCustomerResponse_ReceiptBehaviour(value)
	return nil
}

// ! Options for throttling how many receipts get sent to the server
// ! from the SMART server
type CommsConfig struct {
	OperationMode *CommsConfig_OperationMode `protobuf:"varint,1,req,name=operation_mode,enum=eReceipts.server.service.CommsConfig_OperationMode" json:"operation_mode,omitempty"`
	// ! Maximum number of receipts to queue on SMART when in normal
	// ! mode. This is basically a sanity variable and should rarely
	// ! change.
	MaxQueueLengthNormalOperation *int32 `protobuf:"varint,2,opt,name=max_queue_length_normal_operation,def=100" json:"max_queue_length_normal_operation,omitempty"`
	// ! Maximum number of receipts to queue on SMART when in any
	// ! operation mode but NORMAL
	MaxQueueLengthNonNormalOperation *int32 `protobuf:"varint,3,opt,name=max_queue_length_non_normal_operation,def=10" json:"max_queue_length_non_normal_operation,omitempty"`
	// ! The maximum number of receipts to send to the server in
	// ! each request
	MaxSendBatchSize *int32 `protobuf:"varint,4,opt,name=max_send_batch_size,def=10" json:"max_send_batch_size,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CommsConfig) Reset()         { *m = CommsConfig{} }
func (m *CommsConfig) String() string { return proto.CompactTextString(m) }
func (*CommsConfig) ProtoMessage()    {}

const Default_CommsConfig_MaxQueueLengthNormalOperation int32 = 100
const Default_CommsConfig_MaxQueueLengthNonNormalOperation int32 = 10
const Default_CommsConfig_MaxSendBatchSize int32 = 10

func (m *CommsConfig) GetOperationMode() CommsConfig_OperationMode {
	if m != nil && m.OperationMode != nil {
		return *m.OperationMode
	}
	return CommsConfig_NORMAL
}

func (m *CommsConfig) GetMaxQueueLengthNormalOperation() int32 {
	if m != nil && m.MaxQueueLengthNormalOperation != nil {
		return *m.MaxQueueLengthNormalOperation
	}
	return Default_CommsConfig_MaxQueueLengthNormalOperation
}

func (m *CommsConfig) GetMaxQueueLengthNonNormalOperation() int32 {
	if m != nil && m.MaxQueueLengthNonNormalOperation != nil {
		return *m.MaxQueueLengthNonNormalOperation
	}
	return Default_CommsConfig_MaxQueueLengthNonNormalOperation
}

func (m *CommsConfig) GetMaxSendBatchSize() int32 {
	if m != nil && m.MaxSendBatchSize != nil {
		return *m.MaxSendBatchSize
	}
	return Default_CommsConfig_MaxSendBatchSize
}

type KeyValue struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}

func (m *KeyValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// ! Used in both ISPItem (ISP -> Server) and ReceiptItem (Server ->
// ! ISP).  Most data is "whatever they give us, we give them" except
// ! quantity_sold and quantity_returned which are calculated by Tony/Adam.
type SimplifiedReturns struct {
	// ! Only populated as part of ReceiptItem and Not ISPItem.  Calculated by eReceipts team.
	QuantitySold *int32 `protobuf:"varint,1,opt,name=quantity_sold,def=1" json:"quantity_sold,omitempty"`
	// ! Only populated as part of ReceiptItem and Not ISPItem.  Calculated be eReceipts team.
	QuantityReturned *int32 `protobuf:"varint,2,opt,name=quantity_returned,def=0" json:"quantity_returned,omitempty"`
	// ! Opaque to eReceipts
	TaxFlags *string `protobuf:"bytes,3,opt,name=tax_flags" json:"tax_flags,omitempty"`
	// ! Opaque to eReceipts
	Discount *string `protobuf:"bytes,4,opt,name=discount" json:"discount,omitempty"`
	// ! Opaque to eReceipts
	SerialNumber *string `protobuf:"bytes,5,opt,name=serial_number" json:"serial_number,omitempty"`
	// ! Opaque to eReceipts
	ItemSequence *string `protobuf:"bytes,6,opt,name=item_sequence" json:"item_sequence,omitempty"`
	// ! Opaque to eReceipts
	ItemType *string `protobuf:"bytes,7,opt,name=item_type" json:"item_type,omitempty"`
	// ! Opaque to eReceipts
	LinkedTo *string `protobuf:"bytes,8,opt,name=linked_to" json:"linked_to,omitempty"`
	// ! Opaque to eReceipts
	TaxesApplied *string `protobuf:"bytes,9,opt,name=taxes_applied" json:"taxes_applied,omitempty"`
	// ! Opaque to eReceipts
	OriginalPrice *string `protobuf:"bytes,10,opt,name=original_price" json:"original_price,omitempty"`
	// ! Opaque to eReceipts
	DiscountPercent *string `protobuf:"bytes,11,opt,name=discount_percent" json:"discount_percent,omitempty"`
	// ! Opaque to eReceipts
	ReturnReason *string `protobuf:"bytes,12,opt,name=return_reason" json:"return_reason,omitempty"`
	// ! Opaque to eReceipts
	OptionalData []*KeyValue `protobuf:"bytes,13,rep,name=optional_data" json:"optional_data,omitempty"`
	// ! UPC
	UpcAsScanned     *string `protobuf:"bytes,14,opt,name=upc_as_scanned" json:"upc_as_scanned,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SimplifiedReturns) Reset()         { *m = SimplifiedReturns{} }
func (m *SimplifiedReturns) String() string { return proto.CompactTextString(m) }
func (*SimplifiedReturns) ProtoMessage()    {}

const Default_SimplifiedReturns_QuantitySold int32 = 1
const Default_SimplifiedReturns_QuantityReturned int32 = 0

func (m *SimplifiedReturns) GetQuantitySold() int32 {
	if m != nil && m.QuantitySold != nil {
		return *m.QuantitySold
	}
	return Default_SimplifiedReturns_QuantitySold
}

func (m *SimplifiedReturns) GetQuantityReturned() int32 {
	if m != nil && m.QuantityReturned != nil {
		return *m.QuantityReturned
	}
	return Default_SimplifiedReturns_QuantityReturned
}

func (m *SimplifiedReturns) GetTaxFlags() string {
	if m != nil && m.TaxFlags != nil {
		return *m.TaxFlags
	}
	return ""
}

func (m *SimplifiedReturns) GetDiscount() string {
	if m != nil && m.Discount != nil {
		return *m.Discount
	}
	return ""
}

func (m *SimplifiedReturns) GetSerialNumber() string {
	if m != nil && m.SerialNumber != nil {
		return *m.SerialNumber
	}
	return ""
}

func (m *SimplifiedReturns) GetItemSequence() string {
	if m != nil && m.ItemSequence != nil {
		return *m.ItemSequence
	}
	return ""
}

func (m *SimplifiedReturns) GetItemType() string {
	if m != nil && m.ItemType != nil {
		return *m.ItemType
	}
	return ""
}

func (m *SimplifiedReturns) GetLinkedTo() string {
	if m != nil && m.LinkedTo != nil {
		return *m.LinkedTo
	}
	return ""
}

func (m *SimplifiedReturns) GetTaxesApplied() string {
	if m != nil && m.TaxesApplied != nil {
		return *m.TaxesApplied
	}
	return ""
}

func (m *SimplifiedReturns) GetOriginalPrice() string {
	if m != nil && m.OriginalPrice != nil {
		return *m.OriginalPrice
	}
	return ""
}

func (m *SimplifiedReturns) GetDiscountPercent() string {
	if m != nil && m.DiscountPercent != nil {
		return *m.DiscountPercent
	}
	return ""
}

func (m *SimplifiedReturns) GetReturnReason() string {
	if m != nil && m.ReturnReason != nil {
		return *m.ReturnReason
	}
	return ""
}

func (m *SimplifiedReturns) GetOptionalData() []*KeyValue {
	if m != nil {
		return m.OptionalData
	}
	return nil
}

func (m *SimplifiedReturns) GetUpcAsScanned() string {
	if m != nil && m.UpcAsScanned != nil {
		return *m.UpcAsScanned
	}
	return ""
}

// ! Information from lookup up a UPC against the CISAM database
type ISPItem struct {
	// ! This is now "UPCPrinted"
	RawProductCode *string `protobuf:"bytes,1,req,name=raw_product_code" json:"raw_product_code,omitempty"`
	// ! This is now "ItemNbr"
	ItemId *string `protobuf:"bytes,2,opt,name=item_id" json:"item_id,omitempty"`
	// ! This is now "UPCScanned"
	WinNumber *string `protobuf:"bytes,3,opt,name=win_number" json:"win_number,omitempty"`
	// ! A short description that is hopefully better than what is on the receipt (CISAM)
	ShortDescription *string `protobuf:"bytes,4,opt,name=short_description" json:"short_description,omitempty"`
	// ! A long description that is hopefully much better than what is on the receipt (CISAM)
	LongDescription *string `protobuf:"bytes,5,opt,name=long_description" json:"long_description,omitempty"`
	// ! The department code.  Server should have mapping to good english string.
	Department *string `protobuf:"bytes,6,opt,name=department" json:"department,omitempty"`
	// ! Not populated yet but might be gettable.
	AisleLocation *string `protobuf:"bytes,7,opt,name=aisle_location" json:"aisle_location,omitempty"`
	// DEPRECATED. see SimplifiedReturns message
	TaxFlags *string `protobuf:"bytes,8,opt,name=tax_flags" json:"tax_flags,omitempty"`
	// DEPRECATED. see SimplifiedReturns message
	Discount *string `protobuf:"bytes,9,opt,name=discount" json:"discount,omitempty"`
	// DEPRECATED. see SimplifiedReturns message
	SerialNumber      *string            `protobuf:"bytes,10,opt,name=serial_number" json:"serial_number,omitempty"`
	SimplifiedReturns *SimplifiedReturns `protobuf:"bytes,11,opt,name=simplified_returns" json:"simplified_returns,omitempty"`
	// One hour guarantee item was swapped out.  This is the original UPC for marking picked up
	OneHourGuaranteeOriginalUpc *string `protobuf:"bytes,12,opt,name=one_hour_guarantee_original_upc" json:"one_hour_guarantee_original_upc,omitempty"`
	XXX_unrecognized            []byte  `json:"-"`
}

func (m *ISPItem) Reset()         { *m = ISPItem{} }
func (m *ISPItem) String() string { return proto.CompactTextString(m) }
func (*ISPItem) ProtoMessage()    {}

func (m *ISPItem) GetRawProductCode() string {
	if m != nil && m.RawProductCode != nil {
		return *m.RawProductCode
	}
	return ""
}

func (m *ISPItem) GetItemId() string {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return ""
}

func (m *ISPItem) GetWinNumber() string {
	if m != nil && m.WinNumber != nil {
		return *m.WinNumber
	}
	return ""
}

func (m *ISPItem) GetShortDescription() string {
	if m != nil && m.ShortDescription != nil {
		return *m.ShortDescription
	}
	return ""
}

func (m *ISPItem) GetLongDescription() string {
	if m != nil && m.LongDescription != nil {
		return *m.LongDescription
	}
	return ""
}

func (m *ISPItem) GetDepartment() string {
	if m != nil && m.Department != nil {
		return *m.Department
	}
	return ""
}

func (m *ISPItem) GetAisleLocation() string {
	if m != nil && m.AisleLocation != nil {
		return *m.AisleLocation
	}
	return ""
}

func (m *ISPItem) GetTaxFlags() string {
	if m != nil && m.TaxFlags != nil {
		return *m.TaxFlags
	}
	return ""
}

func (m *ISPItem) GetDiscount() string {
	if m != nil && m.Discount != nil {
		return *m.Discount
	}
	return ""
}

func (m *ISPItem) GetSerialNumber() string {
	if m != nil && m.SerialNumber != nil {
		return *m.SerialNumber
	}
	return ""
}

func (m *ISPItem) GetSimplifiedReturns() *SimplifiedReturns {
	if m != nil {
		return m.SimplifiedReturns
	}
	return nil
}

func (m *ISPItem) GetOneHourGuaranteeOriginalUpc() string {
	if m != nil && m.OneHourGuaranteeOriginalUpc != nil {
		return *m.OneHourGuaranteeOriginalUpc
	}
	return ""
}

// ! A specific line of text on a receipt including meta data and optional
// ! information about the item as looked up on the ISP by UPC code
type ReceiptLine struct {
	// ! The raw text of the line
	Text *string `protobuf:"bytes,1,req,name=text" json:"text,omitempty"`
	// ! Whether this line should be printed at double the size
	IsDoubleSize *bool `protobuf:"varint,2,opt,name=is_double_size" json:"is_double_size,omitempty"`
	// ! Whether the text of this line should be drawn as a barcode
	IsBarcode *bool `protobuf:"varint,3,opt,name=is_barcode" json:"is_barcode,omitempty"`
	// ! How many extra carriage returns to put after this line. (defaults to 0)
	LineAdvance *int32 `protobuf:"varint,4,opt,name=line_advance" json:"line_advance,omitempty"`
	// DEPRECATED and never used.  All UPCs and Item numbers are now in unassigned_purchased_items.
	Item             *ISPItem `protobuf:"bytes,5,opt,name=item" json:"item,omitempty"`
	Mask             *int32   `protobuf:"varint,6,opt,name=mask" json:"mask,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ReceiptLine) Reset()         { *m = ReceiptLine{} }
func (m *ReceiptLine) String() string { return proto.CompactTextString(m) }
func (*ReceiptLine) ProtoMessage()    {}

func (m *ReceiptLine) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *ReceiptLine) GetIsDoubleSize() bool {
	if m != nil && m.IsDoubleSize != nil {
		return *m.IsDoubleSize
	}
	return false
}

func (m *ReceiptLine) GetIsBarcode() bool {
	if m != nil && m.IsBarcode != nil {
		return *m.IsBarcode
	}
	return false
}

func (m *ReceiptLine) GetLineAdvance() int32 {
	if m != nil && m.LineAdvance != nil {
		return *m.LineAdvance
	}
	return 0
}

func (m *ReceiptLine) GetItem() *ISPItem {
	if m != nil {
		return m.Item
	}
	return nil
}

func (m *ReceiptLine) GetMask() int32 {
	if m != nil && m.Mask != nil {
		return *m.Mask
	}
	return 0
}

type GiftReceipt struct {
	// ! The actual content of the receipt.
	ReceiptLines     []*ReceiptLine `protobuf:"bytes,1,rep,name=receipt_lines" json:"receipt_lines,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *GiftReceipt) Reset()         { *m = GiftReceipt{} }
func (m *GiftReceipt) String() string { return proto.CompactTextString(m) }
func (*GiftReceipt) ProtoMessage()    {}

func (m *GiftReceipt) GetReceiptLines() []*ReceiptLine {
	if m != nil {
		return m.ReceiptLines
	}
	return nil
}

// ! Payload sent from the ISP to the eReceipt server for each receipt
// ! captured.
type ISPReceipt struct {
	// ! If MSCO, ruid is the basket id. If standalone eReceipts, this
	// ! is RUID (Random unique id) of the receipt as generated by the
	// ! fep e.g. BQTWpNpW5-lLKX-LJmB-CnJT-DYMOmGksmFI.  62^32
	// ! combinations
	Ruid *string `protobuf:"bytes,1,req,name=ruid" json:"ruid,omitempty"`
	// ! The actual content of the receipt.
	ReceiptLines []*ReceiptLine `protobuf:"bytes,2,rep,name=receipt_lines" json:"receipt_lines,omitempty"`
	// ! Whether or not this receipt is from a Mobile Self-Checkout (MSCO)
	// ! transaction
	IsMsco *bool `protobuf:"varint,3,opt,name=is_msco,def=0" json:"is_msco,omitempty"`
	// ! unix timestamp according to the ISP Server
	IspTimestamp *uint32 `protobuf:"varint,4,req,name=isp_timestamp" json:"isp_timestamp,omitempty"`
	// DEPRICATED - now fep_timestamp
	RegisterTimestamp *string `protobuf:"bytes,5,opt,name=register_timestamp" json:"register_timestamp,omitempty"`
	// ! Walmart's 20-25 digit TC Number
	// ! NOTE: This is not reliable when sent from the ISP. The TC number
	// !       should instead be parsed from the receipt text
	TcNumber *string `protobuf:"bytes,6,opt,name=tc_number" json:"tc_number,omitempty"`
	// ! The ID of the register where the transaction occured
	RegisterId *string `protobuf:"bytes,7,opt,name=register_id" json:"register_id,omitempty"`
	// ! Which template was used for the image was printed on the receipt.
	TemplateId *string `protobuf:"bytes,8,opt,name=template_id" json:"template_id,omitempty"`
	// ! The phonen number read from the debit card reader
	CustomerPhoneNumber *string `protobuf:"bytes,9,opt,name=customer_phone_number" json:"customer_phone_number,omitempty"`
	// ! The url printed on the stub (if any) e.g. https://wmt.co/ruvc789
	ShortUrl *string `protobuf:"bytes,10,opt,name=short_url" json:"short_url,omitempty"`
	// ! Gathered from the CISAM database on the SMART server. Should
	// ! be either WMSC (Walmart Super Center) or SAMS (Sam's Club) or
	// ! WMGM (Walmart Greedy Manticore)
	BusinessType *string `protobuf:"bytes,11,opt,name=business_type" json:"business_type,omitempty"`
	// ! Sam's club membership number or any other Walmart subsidiary's
	// ! membership number
	MembershipNumber *string `protobuf:"bytes,12,opt,name=membership_number" json:"membership_number,omitempty"`
	// ! Unix Timestamp according to the fep
	FepTimestamp *uint32 `protobuf:"varint,13,opt,name=fep_timestamp" json:"fep_timestamp,omitempty"`
	// ! Now that we get printed UPCs, all UPCs supplied to us will be in here and the search is done server side.
	UnassignedPurchasedItems []*ISPItem `protobuf:"bytes,14,rep,name=unassigned_purchased_items" json:"unassigned_purchased_items,omitempty"`
	// ! Which A/B setup was used on the debit card reader
	CardReaderProfile *string `protobuf:"bytes,15,opt,name=card_reader_profile" json:"card_reader_profile,omitempty"`
	// ! Sequence of events that the user took on the card reader for analytics purposes
	CardReaderAnalyticsEvent []string `protobuf:"bytes,16,rep,name=card_reader_analytics_event" json:"card_reader_analytics_event,omitempty"`
	// ! If presetn, the MD5 sum of the header/logo image.  This should
	// ! match the MD5 sum of one of the images in
	// ! StaticImageDataRequest
	HeaderImageMd5 *string `protobuf:"bytes,17,opt,name=header_image_md5" json:"header_image_md5,omitempty"`
	// ! As per header_image_md5 but for a footer
	FooterImageMd5 *string `protobuf:"bytes,18,opt,name=footer_image_md5" json:"footer_image_md5,omitempty"`
	// ! At least Sam's club puts the survey into an image for faster
	// ! printing (stored on printer).
	SurveyImageMd5   *string `protobuf:"bytes,19,opt,name=survey_image_md5" json:"survey_image_md5,omitempty"`
	CustomerWantsSms *bool   `protobuf:"varint,20,opt,name=customer_wants_sms,def=0" json:"customer_wants_sms,omitempty"`
	// ! Gift receipts (if any)
	GiftReceipts []*GiftReceipt `protobuf:"bytes,21,rep,name=gift_receipts" json:"gift_receipts,omitempty"`
	// ! Is there at least one 1HourGuarantee virtual item on this receipt?
	HasOneHourGuaranteeVirtualItems *bool `protobuf:"varint,22,opt,name=has_one_hour_guarantee_virtual_items" json:"has_one_hour_guarantee_virtual_items,omitempty"`
	// ! The 16 digit gift card number. Sent on purchase of virtual item.
	OneHourGuaranteeGiftCardNumber *string `protobuf:"bytes,23,opt,name=one_hour_guarantee_gift_card_number" json:"one_hour_guarantee_gift_card_number,omitempty"`
	// ! When the 1HG item is picked up a new receipt is issued.  This
	// ! is a linkage TCNumber to the receipt that had the virtual
	// ! items above.  i.e. the receipt that
	// ! has_one_hour_guarantee_virtual_items is true
	OneHourGuaranteeOriginalTcNumber *string `protobuf:"bytes,24,opt,name=one_hour_guarantee_original_tc_number" json:"one_hour_guarantee_original_tc_number,omitempty"`
	XXX_unrecognized                 []byte  `json:"-"`
}

func (m *ISPReceipt) Reset()         { *m = ISPReceipt{} }
func (m *ISPReceipt) String() string { return proto.CompactTextString(m) }
func (*ISPReceipt) ProtoMessage()    {}

const Default_ISPReceipt_IsMsco bool = false
const Default_ISPReceipt_CustomerWantsSms bool = false

func (m *ISPReceipt) GetRuid() string {
	if m != nil && m.Ruid != nil {
		return *m.Ruid
	}
	return ""
}

func (m *ISPReceipt) GetReceiptLines() []*ReceiptLine {
	if m != nil {
		return m.ReceiptLines
	}
	return nil
}

func (m *ISPReceipt) GetIsMsco() bool {
	if m != nil && m.IsMsco != nil {
		return *m.IsMsco
	}
	return Default_ISPReceipt_IsMsco
}

func (m *ISPReceipt) GetIspTimestamp() uint32 {
	if m != nil && m.IspTimestamp != nil {
		return *m.IspTimestamp
	}
	return 0
}

func (m *ISPReceipt) GetRegisterTimestamp() string {
	if m != nil && m.RegisterTimestamp != nil {
		return *m.RegisterTimestamp
	}
	return ""
}

func (m *ISPReceipt) GetTcNumber() string {
	if m != nil && m.TcNumber != nil {
		return *m.TcNumber
	}
	return ""
}

func (m *ISPReceipt) GetRegisterId() string {
	if m != nil && m.RegisterId != nil {
		return *m.RegisterId
	}
	return ""
}

func (m *ISPReceipt) GetTemplateId() string {
	if m != nil && m.TemplateId != nil {
		return *m.TemplateId
	}
	return ""
}

func (m *ISPReceipt) GetCustomerPhoneNumber() string {
	if m != nil && m.CustomerPhoneNumber != nil {
		return *m.CustomerPhoneNumber
	}
	return ""
}

func (m *ISPReceipt) GetShortUrl() string {
	if m != nil && m.ShortUrl != nil {
		return *m.ShortUrl
	}
	return ""
}

func (m *ISPReceipt) GetBusinessType() string {
	if m != nil && m.BusinessType != nil {
		return *m.BusinessType
	}
	return ""
}

func (m *ISPReceipt) GetMembershipNumber() string {
	if m != nil && m.MembershipNumber != nil {
		return *m.MembershipNumber
	}
	return ""
}

func (m *ISPReceipt) GetFepTimestamp() uint32 {
	if m != nil && m.FepTimestamp != nil {
		return *m.FepTimestamp
	}
	return 0
}

func (m *ISPReceipt) GetUnassignedPurchasedItems() []*ISPItem {
	if m != nil {
		return m.UnassignedPurchasedItems
	}
	return nil
}

func (m *ISPReceipt) GetCardReaderProfile() string {
	if m != nil && m.CardReaderProfile != nil {
		return *m.CardReaderProfile
	}
	return ""
}

func (m *ISPReceipt) GetCardReaderAnalyticsEvent() []string {
	if m != nil {
		return m.CardReaderAnalyticsEvent
	}
	return nil
}

func (m *ISPReceipt) GetHeaderImageMd5() string {
	if m != nil && m.HeaderImageMd5 != nil {
		return *m.HeaderImageMd5
	}
	return ""
}

func (m *ISPReceipt) GetFooterImageMd5() string {
	if m != nil && m.FooterImageMd5 != nil {
		return *m.FooterImageMd5
	}
	return ""
}

func (m *ISPReceipt) GetSurveyImageMd5() string {
	if m != nil && m.SurveyImageMd5 != nil {
		return *m.SurveyImageMd5
	}
	return ""
}

func (m *ISPReceipt) GetCustomerWantsSms() bool {
	if m != nil && m.CustomerWantsSms != nil {
		return *m.CustomerWantsSms
	}
	return Default_ISPReceipt_CustomerWantsSms
}

func (m *ISPReceipt) GetGiftReceipts() []*GiftReceipt {
	if m != nil {
		return m.GiftReceipts
	}
	return nil
}

func (m *ISPReceipt) GetHasOneHourGuaranteeVirtualItems() bool {
	if m != nil && m.HasOneHourGuaranteeVirtualItems != nil {
		return *m.HasOneHourGuaranteeVirtualItems
	}
	return false
}

func (m *ISPReceipt) GetOneHourGuaranteeGiftCardNumber() string {
	if m != nil && m.OneHourGuaranteeGiftCardNumber != nil {
		return *m.OneHourGuaranteeGiftCardNumber
	}
	return ""
}

func (m *ISPReceipt) GetOneHourGuaranteeOriginalTcNumber() string {
	if m != nil && m.OneHourGuaranteeOriginalTcNumber != nil {
		return *m.OneHourGuaranteeOriginalTcNumber
	}
	return ""
}

type UploadReceiptRequest struct {
	// ! We can upload more than one receipt at a time.  Max in batch is
	// ! specified in HeartbeatResponse
	Receipts         []*ISPReceipt `protobuf:"bytes,1,rep,name=receipts" json:"receipts,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *UploadReceiptRequest) Reset()         { *m = UploadReceiptRequest{} }
func (m *UploadReceiptRequest) String() string { return proto.CompactTextString(m) }
func (*UploadReceiptRequest) ProtoMessage()    {}

func (m *UploadReceiptRequest) GetReceipts() []*ISPReceipt {
	if m != nil {
		return m.Receipts
	}
	return nil
}

type UploadReceiptResponse struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *UploadReceiptResponse) Reset()         { *m = UploadReceiptResponse{} }
func (m *UploadReceiptResponse) String() string { return proto.CompactTextString(m) }
func (*UploadReceiptResponse) ProtoMessage()    {}

type ReceiptItem struct {
	Ruid                  *string            `protobuf:"bytes,1,req,name=ruid" json:"ruid,omitempty"`
	ItemNumber            *string            `protobuf:"bytes,2,req,name=item_number" json:"item_number,omitempty"`
	Upc                   *string            `protobuf:"bytes,3,req,name=upc" json:"upc,omitempty"`
	NameOnReceipt         *string            `protobuf:"bytes,4,req,name=name_on_receipt" json:"name_on_receipt,omitempty"`
	PriceInCents          *int32             `protobuf:"varint,5,req,name=price_in_cents" json:"price_in_cents,omitempty"`
	SaverRebateGivenCents *int32             `protobuf:"varint,6,opt,name=saver_rebate_given_cents" json:"saver_rebate_given_cents,omitempty"`
	SaverReturnPriceCents *int32             `protobuf:"varint,7,opt,name=saver_return_price_cents" json:"saver_return_price_cents,omitempty"`
	SimplifiedReturns     *SimplifiedReturns `protobuf:"bytes,8,opt,name=simplified_returns" json:"simplified_returns,omitempty"`
	XXX_unrecognized      []byte             `json:"-"`
}

func (m *ReceiptItem) Reset()         { *m = ReceiptItem{} }
func (m *ReceiptItem) String() string { return proto.CompactTextString(m) }
func (*ReceiptItem) ProtoMessage()    {}

func (m *ReceiptItem) GetRuid() string {
	if m != nil && m.Ruid != nil {
		return *m.Ruid
	}
	return ""
}

func (m *ReceiptItem) GetItemNumber() string {
	if m != nil && m.ItemNumber != nil {
		return *m.ItemNumber
	}
	return ""
}

func (m *ReceiptItem) GetUpc() string {
	if m != nil && m.Upc != nil {
		return *m.Upc
	}
	return ""
}

func (m *ReceiptItem) GetNameOnReceipt() string {
	if m != nil && m.NameOnReceipt != nil {
		return *m.NameOnReceipt
	}
	return ""
}

func (m *ReceiptItem) GetPriceInCents() int32 {
	if m != nil && m.PriceInCents != nil {
		return *m.PriceInCents
	}
	return 0
}

func (m *ReceiptItem) GetSaverRebateGivenCents() int32 {
	if m != nil && m.SaverRebateGivenCents != nil {
		return *m.SaverRebateGivenCents
	}
	return 0
}

func (m *ReceiptItem) GetSaverReturnPriceCents() int32 {
	if m != nil && m.SaverReturnPriceCents != nil {
		return *m.SaverReturnPriceCents
	}
	return 0
}

func (m *ReceiptItem) GetSimplifiedReturns() *SimplifiedReturns {
	if m != nil {
		return m.SimplifiedReturns
	}
	return nil
}

// 1309 additional returns functionality
type ReceiptForReturn struct {
	ReturnableItems    []*ReceiptItem `protobuf:"bytes,1,rep,name=returnable_items" json:"returnable_items,omitempty"`
	NonReturnableItems []*ReceiptItem `protobuf:"bytes,2,rep,name=non_returnable_items" json:"non_returnable_items,omitempty"`
	Ruid               *string        `protobuf:"bytes,3,req,name=ruid" json:"ruid,omitempty"`
	// As per receipt e.g. MM/DD/YYYY (not including time)
	Date *string `protobuf:"bytes,4,req,name=date" json:"date,omitempty"`
	// ! e.g "5260"
	StoreNumber      *string `protobuf:"bytes,5,req,name=store_number" json:"store_number,omitempty"`
	TotalInCents     *int32  `protobuf:"varint,6,req,name=total_in_cents" json:"total_in_cents,omitempty"`
	TcNumber         *string `protobuf:"bytes,7,req,name=tc_number" json:"tc_number,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ReceiptForReturn) Reset()         { *m = ReceiptForReturn{} }
func (m *ReceiptForReturn) String() string { return proto.CompactTextString(m) }
func (*ReceiptForReturn) ProtoMessage()    {}

func (m *ReceiptForReturn) GetReturnableItems() []*ReceiptItem {
	if m != nil {
		return m.ReturnableItems
	}
	return nil
}

func (m *ReceiptForReturn) GetNonReturnableItems() []*ReceiptItem {
	if m != nil {
		return m.NonReturnableItems
	}
	return nil
}

func (m *ReceiptForReturn) GetRuid() string {
	if m != nil && m.Ruid != nil {
		return *m.Ruid
	}
	return ""
}

func (m *ReceiptForReturn) GetDate() string {
	if m != nil && m.Date != nil {
		return *m.Date
	}
	return ""
}

func (m *ReceiptForReturn) GetStoreNumber() string {
	if m != nil && m.StoreNumber != nil {
		return *m.StoreNumber
	}
	return ""
}

func (m *ReceiptForReturn) GetTotalInCents() int32 {
	if m != nil && m.TotalInCents != nil {
		return *m.TotalInCents
	}
	return 0
}

func (m *ReceiptForReturn) GetTcNumber() string {
	if m != nil && m.TcNumber != nil {
		return *m.TcNumber
	}
	return ""
}

type StoredReceipt struct {
	// ! The actual content of the receipt.  Do not bother with the
	// ! ISPItem.
	ReceiptLines     []*ReceiptLine `protobuf:"bytes,1,rep,name=receipt_lines" json:"receipt_lines,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *StoredReceipt) Reset()         { *m = StoredReceipt{} }
func (m *StoredReceipt) String() string { return proto.CompactTextString(m) }
func (*StoredReceipt) ProtoMessage()    {}

func (m *StoredReceipt) GetReceiptLines() []*ReceiptLine {
	if m != nil {
		return m.ReceiptLines
	}
	return nil
}

type CustomerReceiptsRequest struct {
	// ! Was a bad move making this required.  Will pass "empty" when its Sam's club
	PhoneNumber *string `protobuf:"bytes,1,req,name=phone_number" json:"phone_number,omitempty"`
	MaxReceipts *int32  `protobuf:"varint,2,opt,name=max_receipts,def=10" json:"max_receipts,omitempty"`
	// Filter receipts by a UPC
	Upc *string `protobuf:"bytes,3,opt,name=upc" json:"upc,omitempty"`
	// ! Sam's club membership number or any other Walmart subsidiary's
	// ! membership number
	MembershipNumber *string `protobuf:"bytes,4,opt,name=membership_number" json:"membership_number,omitempty"`
	// ! yyyyMMdd.  Only include receipts that are on or after this date.  Format is same as POS supplies fep.
	FromDate *string `protobuf:"bytes,5,opt,name=from_date" json:"from_date,omitempty"`
	// ! yyyyMMdd.  Only include receipts that are on or before this date.  Format is same as POS supplies fep.
	ToDate           *string `protobuf:"bytes,6,opt,name=to_date" json:"to_date,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CustomerReceiptsRequest) Reset()         { *m = CustomerReceiptsRequest{} }
func (m *CustomerReceiptsRequest) String() string { return proto.CompactTextString(m) }
func (*CustomerReceiptsRequest) ProtoMessage()    {}

const Default_CustomerReceiptsRequest_MaxReceipts int32 = 10

func (m *CustomerReceiptsRequest) GetPhoneNumber() string {
	if m != nil && m.PhoneNumber != nil {
		return *m.PhoneNumber
	}
	return ""
}

func (m *CustomerReceiptsRequest) GetMaxReceipts() int32 {
	if m != nil && m.MaxReceipts != nil {
		return *m.MaxReceipts
	}
	return Default_CustomerReceiptsRequest_MaxReceipts
}

func (m *CustomerReceiptsRequest) GetUpc() string {
	if m != nil && m.Upc != nil {
		return *m.Upc
	}
	return ""
}

func (m *CustomerReceiptsRequest) GetMembershipNumber() string {
	if m != nil && m.MembershipNumber != nil {
		return *m.MembershipNumber
	}
	return ""
}

func (m *CustomerReceiptsRequest) GetFromDate() string {
	if m != nil && m.FromDate != nil {
		return *m.FromDate
	}
	return ""
}

func (m *CustomerReceiptsRequest) GetToDate() string {
	if m != nil && m.ToDate != nil {
		return *m.ToDate
	}
	return ""
}

type CustomerReceiptsResponse struct {
	Receipts         []*ReceiptForReturn `protobuf:"bytes,1,rep,name=receipts" json:"receipts,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *CustomerReceiptsResponse) Reset()         { *m = CustomerReceiptsResponse{} }
func (m *CustomerReceiptsResponse) String() string { return proto.CompactTextString(m) }
func (*CustomerReceiptsResponse) ProtoMessage()    {}

func (m *CustomerReceiptsResponse) GetReceipts() []*ReceiptForReturn {
	if m != nil {
		return m.Receipts
	}
	return nil
}

type ReceiptForReturnRequest struct {
	TcNumber         *string `protobuf:"bytes,1,req,name=tc_number" json:"tc_number,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ReceiptForReturnRequest) Reset()         { *m = ReceiptForReturnRequest{} }
func (m *ReceiptForReturnRequest) String() string { return proto.CompactTextString(m) }
func (*ReceiptForReturnRequest) ProtoMessage()    {}

func (m *ReceiptForReturnRequest) GetTcNumber() string {
	if m != nil && m.TcNumber != nil {
		return *m.TcNumber
	}
	return ""
}

type ReceiptForReturnResponse struct {
	Receipt          *ReceiptForReturn `protobuf:"bytes,1,opt,name=receipt" json:"receipt,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *ReceiptForReturnResponse) Reset()         { *m = ReceiptForReturnResponse{} }
func (m *ReceiptForReturnResponse) String() string { return proto.CompactTextString(m) }
func (*ReceiptForReturnResponse) ProtoMessage()    {}

func (m *ReceiptForReturnResponse) GetReceipt() *ReceiptForReturn {
	if m != nil {
		return m.Receipt
	}
	return nil
}

type ReceiptHistoryRequest struct {
	// ! Walmart's 20-25 digit TC Number as scanned off paper receipt,
	// ! eReceipt or keyed in by associate.
	TcNumber *string `protobuf:"bytes,1,req,name=tc_number" json:"tc_number,omitempty"`
	// ! Just a summary of returned and returnable or a full history?
	SummaryFormat    *bool  `protobuf:"varint,2,req,name=summary_format" json:"summary_format,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ReceiptHistoryRequest) Reset()         { *m = ReceiptHistoryRequest{} }
func (m *ReceiptHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*ReceiptHistoryRequest) ProtoMessage()    {}

func (m *ReceiptHistoryRequest) GetTcNumber() string {
	if m != nil && m.TcNumber != nil {
		return *m.TcNumber
	}
	return ""
}

func (m *ReceiptHistoryRequest) GetSummaryFormat() bool {
	if m != nil && m.SummaryFormat != nil {
		return *m.SummaryFormat
	}
	return false
}

type ReceiptHistoryResponse struct {
	// ! Note: We've been told that TC Numbers can collide due to a 20
	// ! year old bug.  The server needs to do some smarts to detect
	// ! and remove collisions based on things like date, location, is
	// ! it a return receipt etc.
	Receipt          *StoredReceipt `protobuf:"bytes,1,opt,name=receipt" json:"receipt,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ReceiptHistoryResponse) Reset()         { *m = ReceiptHistoryResponse{} }
func (m *ReceiptHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*ReceiptHistoryResponse) ProtoMessage()    {}

func (m *ReceiptHistoryResponse) GetReceipt() *StoredReceipt {
	if m != nil {
		return m.Receipt
	}
	return nil
}

// ! POS need this info for OneHourGuarantee pickups flow
type OneHourGuaranteeVirtualItem struct {
	// ! Matches the printed UPC for the virtual item on the original receipt.
	UpcPrinted *string `protobuf:"bytes,1,req,name=upc_printed" json:"upc_printed,omitempty"`
	// ! The price in cents on the original receipt
	PriceInCents *int32 `protobuf:"varint,2,req,name=price_in_cents" json:"price_in_cents,omitempty"`
	// ! Has this item already been picked up?  i.e. we need to mark
	// ! pickups in ISPReceipt.one_hg_original_tc_number.
	HasBeenPickedUp  *bool  `protobuf:"varint,3,opt,name=has_been_picked_up,def=0" json:"has_been_picked_up,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *OneHourGuaranteeVirtualItem) Reset()         { *m = OneHourGuaranteeVirtualItem{} }
func (m *OneHourGuaranteeVirtualItem) String() string { return proto.CompactTextString(m) }
func (*OneHourGuaranteeVirtualItem) ProtoMessage()    {}

const Default_OneHourGuaranteeVirtualItem_HasBeenPickedUp bool = false

func (m *OneHourGuaranteeVirtualItem) GetUpcPrinted() string {
	if m != nil && m.UpcPrinted != nil {
		return *m.UpcPrinted
	}
	return ""
}

func (m *OneHourGuaranteeVirtualItem) GetPriceInCents() int32 {
	if m != nil && m.PriceInCents != nil {
		return *m.PriceInCents
	}
	return 0
}

func (m *OneHourGuaranteeVirtualItem) GetHasBeenPickedUp() bool {
	if m != nil && m.HasBeenPickedUp != nil {
		return *m.HasBeenPickedUp
	}
	return Default_OneHourGuaranteeVirtualItem_HasBeenPickedUp
}

// ! The "virtual" gift card that is printed on the receipt for the
// ! customer to spend on their 1HourGuarantee item
type OneHourGuaranteeGiftCard struct {
	// ! 16 digit number.  PIN is NOT sent up in structured.  No idea if
	// ! it is printed on receipt.
	Number           *string `protobuf:"bytes,1,req,name=number" json:"number,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *OneHourGuaranteeGiftCard) Reset()         { *m = OneHourGuaranteeGiftCard{} }
func (m *OneHourGuaranteeGiftCard) String() string { return proto.CompactTextString(m) }
func (*OneHourGuaranteeGiftCard) ProtoMessage()    {}

func (m *OneHourGuaranteeGiftCard) GetNumber() string {
	if m != nil && m.Number != nil {
		return *m.Number
	}
	return ""
}

// ! 1407 1HourGuarantee Additions.
type OneHourGuaranteeLookup struct {
	// As per receipt e.g. MM/DD/YYYY (not including time)
	Date *string `protobuf:"bytes,1,req,name=date" json:"date,omitempty"`
	// ! e.g "5260"
	StoreNumber  *string `protobuf:"bytes,2,req,name=store_number" json:"store_number,omitempty"`
	TotalInCents *int32  `protobuf:"varint,3,req,name=total_in_cents" json:"total_in_cents,omitempty"`
	// ! All the 1HG virtual items on the original receipt.
	VirtualItems []*OneHourGuaranteeVirtualItem `protobuf:"bytes,4,rep,name=virtual_items" json:"virtual_items,omitempty"`
	// ! Gift card printed on original receipt (see
	// ! ISPReceipt.one_hour_guarantee_gift_card_number).  Note: used
	// ! structure in case they want to add back in PIN.
	GiftCard         *OneHourGuaranteeGiftCard `protobuf:"bytes,5,req,name=gift_card" json:"gift_card,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *OneHourGuaranteeLookup) Reset()         { *m = OneHourGuaranteeLookup{} }
func (m *OneHourGuaranteeLookup) String() string { return proto.CompactTextString(m) }
func (*OneHourGuaranteeLookup) ProtoMessage()    {}

func (m *OneHourGuaranteeLookup) GetDate() string {
	if m != nil && m.Date != nil {
		return *m.Date
	}
	return ""
}

func (m *OneHourGuaranteeLookup) GetStoreNumber() string {
	if m != nil && m.StoreNumber != nil {
		return *m.StoreNumber
	}
	return ""
}

func (m *OneHourGuaranteeLookup) GetTotalInCents() int32 {
	if m != nil && m.TotalInCents != nil {
		return *m.TotalInCents
	}
	return 0
}

func (m *OneHourGuaranteeLookup) GetVirtualItems() []*OneHourGuaranteeVirtualItem {
	if m != nil {
		return m.VirtualItems
	}
	return nil
}

func (m *OneHourGuaranteeLookup) GetGiftCard() *OneHourGuaranteeGiftCard {
	if m != nil {
		return m.GiftCard
	}
	return nil
}

// ! 1407 1HG Additions.
type OneHourGuaranteeLookupRequest struct {
	TcNumber         *string `protobuf:"bytes,1,req,name=tc_number" json:"tc_number,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *OneHourGuaranteeLookupRequest) Reset()         { *m = OneHourGuaranteeLookupRequest{} }
func (m *OneHourGuaranteeLookupRequest) String() string { return proto.CompactTextString(m) }
func (*OneHourGuaranteeLookupRequest) ProtoMessage()    {}

func (m *OneHourGuaranteeLookupRequest) GetTcNumber() string {
	if m != nil && m.TcNumber != nil {
		return *m.TcNumber
	}
	return ""
}

// ! 1407 1HG Additions.
type OneHourGuaranteeLookupResponse struct {
	DetailsFromOriginalReceipt *OneHourGuaranteeLookup `protobuf:"bytes,1,opt,name=details_from_original_receipt" json:"details_from_original_receipt,omitempty"`
	XXX_unrecognized           []byte                  `json:"-"`
}

func (m *OneHourGuaranteeLookupResponse) Reset()         { *m = OneHourGuaranteeLookupResponse{} }
func (m *OneHourGuaranteeLookupResponse) String() string { return proto.CompactTextString(m) }
func (*OneHourGuaranteeLookupResponse) ProtoMessage()    {}

func (m *OneHourGuaranteeLookupResponse) GetDetailsFromOriginalReceipt() *OneHourGuaranteeLookup {
	if m != nil {
		return m.DetailsFromOriginalReceipt
	}
	return nil
}

// ! Image template
type TemplateImage struct {
	// ! Id used to e.g. 11.png
	TemplateId *string `protobuf:"bytes,1,req,name=template_id" json:"template_id,omitempty"`
	// ! Image data (PNG!)
	PngImage []byte `protobuf:"bytes,2,req,name=png_image" json:"png_image,omitempty"`
	// ! Should this image be used instead of the Walmart/SamsClub logo
	// ! instead of simply being appended to the receipt?
	ReplacesTopLogo  *bool  `protobuf:"varint,3,opt,name=replaces_top_logo,def=0" json:"replaces_top_logo,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TemplateImage) Reset()         { *m = TemplateImage{} }
func (m *TemplateImage) String() string { return proto.CompactTextString(m) }
func (*TemplateImage) ProtoMessage()    {}

const Default_TemplateImage_ReplacesTopLogo bool = false

func (m *TemplateImage) GetTemplateId() string {
	if m != nil && m.TemplateId != nil {
		return *m.TemplateId
	}
	return ""
}

func (m *TemplateImage) GetPngImage() []byte {
	if m != nil {
		return m.PngImage
	}
	return nil
}

func (m *TemplateImage) GetReplacesTopLogo() bool {
	if m != nil && m.ReplacesTopLogo != nil {
		return *m.ReplacesTopLogo
	}
	return Default_TemplateImage_ReplacesTopLogo
}

// ! Defaults templates images for the entire store
type TemplatesConfigDefault struct {
	// ! The set of templates to choose from for each transaction for
	// ! the scenario that no customer identity was capture.
	TemplateIdsForNoCustomerIdentityProvided []string `protobuf:"bytes,1,rep,name=template_ids_for_no_customer_identity_provided" json:"template_ids_for_no_customer_identity_provided,omitempty"`
	// ! The set of templates to choose from for each transaction for
	// ! the scenario that whatever the customer identity entered
	// ! (phone, membership card) we weren't able to find a record of
	// ! that customer (not registered or lookup didn't return fast
	// ! enough).
	TemplateIdsForCustomerIdentityNotFound []string `protobuf:"bytes,2,rep,name=template_ids_for_customer_identity_not_found" json:"template_ids_for_customer_identity_not_found,omitempty"`
	// ! The customer is registered but they still want a paper
	// ! receipt.  We can put an image on there that reinforces
	// ! eReceipts or advertises a new feature of eReceipts (like
	// ! budgeting, Walmart Saver etc)
	TemplateIdsForCustomerWantsPaperAndEreceipt []string `protobuf:"bytes,3,rep,name=template_ids_for_customer_wants_paper_and_ereceipt" json:"template_ids_for_customer_wants_paper_and_ereceipt,omitempty"`
	XXX_unrecognized                            []byte   `json:"-"`
}

func (m *TemplatesConfigDefault) Reset()         { *m = TemplatesConfigDefault{} }
func (m *TemplatesConfigDefault) String() string { return proto.CompactTextString(m) }
func (*TemplatesConfigDefault) ProtoMessage()    {}

func (m *TemplatesConfigDefault) GetTemplateIdsForNoCustomerIdentityProvided() []string {
	if m != nil {
		return m.TemplateIdsForNoCustomerIdentityProvided
	}
	return nil
}

func (m *TemplatesConfigDefault) GetTemplateIdsForCustomerIdentityNotFound() []string {
	if m != nil {
		return m.TemplateIdsForCustomerIdentityNotFound
	}
	return nil
}

func (m *TemplatesConfigDefault) GetTemplateIdsForCustomerWantsPaperAndEreceipt() []string {
	if m != nil {
		return m.TemplateIdsForCustomerWantsPaperAndEreceipt
	}
	return nil
}

// ! Overides to templates images per register
type TemplatesConfigOverride struct {
	// ! The register id that the overide applies for (also called terminal number).
	RegisterId *string `protobuf:"bytes,4,req,name=register_id" json:"register_id,omitempty"`
	// ! see TemplatesConfigDefault
	TemplateIdsForNoCustomerIdentityProvided []string `protobuf:"bytes,1,rep,name=template_ids_for_no_customer_identity_provided" json:"template_ids_for_no_customer_identity_provided,omitempty"`
	// ! see TemplatesConfigDefault
	TemplateIdsForCustomerIdentityNotFound []string `protobuf:"bytes,2,rep,name=template_ids_for_customer_identity_not_found" json:"template_ids_for_customer_identity_not_found,omitempty"`
	// ! see TemplatesConfigDefault
	TemplateIdsForCustomerWantsPaperAndEreceipt []string `protobuf:"bytes,3,rep,name=template_ids_for_customer_wants_paper_and_ereceipt" json:"template_ids_for_customer_wants_paper_and_ereceipt,omitempty"`
	XXX_unrecognized                            []byte   `json:"-"`
}

func (m *TemplatesConfigOverride) Reset()         { *m = TemplatesConfigOverride{} }
func (m *TemplatesConfigOverride) String() string { return proto.CompactTextString(m) }
func (*TemplatesConfigOverride) ProtoMessage()    {}

func (m *TemplatesConfigOverride) GetRegisterId() string {
	if m != nil && m.RegisterId != nil {
		return *m.RegisterId
	}
	return ""
}

func (m *TemplatesConfigOverride) GetTemplateIdsForNoCustomerIdentityProvided() []string {
	if m != nil {
		return m.TemplateIdsForNoCustomerIdentityProvided
	}
	return nil
}

func (m *TemplatesConfigOverride) GetTemplateIdsForCustomerIdentityNotFound() []string {
	if m != nil {
		return m.TemplateIdsForCustomerIdentityNotFound
	}
	return nil
}

func (m *TemplatesConfigOverride) GetTemplateIdsForCustomerWantsPaperAndEreceipt() []string {
	if m != nil {
		return m.TemplateIdsForCustomerWantsPaperAndEreceipt
	}
	return nil
}

// ! Ask server for all the template information but don't send down
// ! new images if we already have them.
type SyncTemplatesRequest struct {
	// ! The template Ids for images that we already have.
	ExistingTemplateIds []string `protobuf:"bytes,1,rep,name=existing_template_ids" json:"existing_template_ids,omitempty"`
	XXX_unrecognized    []byte   `json:"-"`
}

func (m *SyncTemplatesRequest) Reset()         { *m = SyncTemplatesRequest{} }
func (m *SyncTemplatesRequest) String() string { return proto.CompactTextString(m) }
func (*SyncTemplatesRequest) ProtoMessage()    {}

func (m *SyncTemplatesRequest) GetExistingTemplateIds() []string {
	if m != nil {
		return m.ExistingTemplateIds
	}
	return nil
}

// ! The latest template image configuration
type SyncTemplatesResponse struct {
	// ! Store wide defaults
	TemplatesDefault *TemplatesConfigDefault `protobuf:"bytes,1,req,name=templates_default" json:"templates_default,omitempty"`
	// ! Any register overrides
	TemplatesRegisterOverrides []*TemplatesConfigOverride `protobuf:"bytes,2,rep,name=templates_register_overrides" json:"templates_register_overrides,omitempty"`
	// ! The set of image data that we don't already have (server should
	// ! not send us images that have ids in
	// ! SyncTemplatesRequest.existing_template_ids)
	NewTemplates []*TemplateImage `protobuf:"bytes,3,rep,name=new_templates" json:"new_templates,omitempty"`
	// ! Only text & is_double_size is used from ReceiptLine
	NoCustomerIdentityProvidedAlternateText []*ReceiptLine `protobuf:"bytes,4,rep,name=no_customer_identity_provided_alternate_text" json:"no_customer_identity_provided_alternate_text,omitempty"`
	// ! Only text & is_double_size is used from ReceiptLine
	CustomerIdentityNotFoundAlternateText []*ReceiptLine `protobuf:"bytes,5,rep,name=customer_identity_not_found_alternate_text" json:"customer_identity_not_found_alternate_text,omitempty"`
	// ! Only text & is_double_size is used from ReceiptLine
	CustomerWantsPaperAndEreceiptAlternateText []*ReceiptLine `protobuf:"bytes,6,rep,name=customer_wants_paper_and_ereceipt_alternate_text" json:"customer_wants_paper_and_ereceipt_alternate_text,omitempty"`
	// ! e.g. WALMART SAVER PRICE OVERRIDE (put after every item that had a price override)
	SaverReturnSlipLineAssociate *string `protobuf:"bytes,7,opt,name=saver_return_slip_line_associate" json:"saver_return_slip_line_associate,omitempty"`
	// ! WALMART SAVER PRICE OVERRIDE(S).  Added to receipts that had saver price override(s)
	SaverReturnSlipLineCustomer *string `protobuf:"bytes,8,opt,name=saver_return_slip_line_customer" json:"saver_return_slip_line_customer,omitempty"`
	XXX_unrecognized            []byte  `json:"-"`
}

func (m *SyncTemplatesResponse) Reset()         { *m = SyncTemplatesResponse{} }
func (m *SyncTemplatesResponse) String() string { return proto.CompactTextString(m) }
func (*SyncTemplatesResponse) ProtoMessage()    {}

func (m *SyncTemplatesResponse) GetTemplatesDefault() *TemplatesConfigDefault {
	if m != nil {
		return m.TemplatesDefault
	}
	return nil
}

func (m *SyncTemplatesResponse) GetTemplatesRegisterOverrides() []*TemplatesConfigOverride {
	if m != nil {
		return m.TemplatesRegisterOverrides
	}
	return nil
}

func (m *SyncTemplatesResponse) GetNewTemplates() []*TemplateImage {
	if m != nil {
		return m.NewTemplates
	}
	return nil
}

func (m *SyncTemplatesResponse) GetNoCustomerIdentityProvidedAlternateText() []*ReceiptLine {
	if m != nil {
		return m.NoCustomerIdentityProvidedAlternateText
	}
	return nil
}

func (m *SyncTemplatesResponse) GetCustomerIdentityNotFoundAlternateText() []*ReceiptLine {
	if m != nil {
		return m.CustomerIdentityNotFoundAlternateText
	}
	return nil
}

func (m *SyncTemplatesResponse) GetCustomerWantsPaperAndEreceiptAlternateText() []*ReceiptLine {
	if m != nil {
		return m.CustomerWantsPaperAndEreceiptAlternateText
	}
	return nil
}

func (m *SyncTemplatesResponse) GetSaverReturnSlipLineAssociate() string {
	if m != nil && m.SaverReturnSlipLineAssociate != nil {
		return *m.SaverReturnSlipLineAssociate
	}
	return ""
}

func (m *SyncTemplatesResponse) GetSaverReturnSlipLineCustomer() string {
	if m != nil && m.SaverReturnSlipLineCustomer != nil {
		return *m.SaverReturnSlipLineCustomer
	}
	return ""
}

// ! Attributes that reflect AB testable attributes of the card reader
// ! display.  e.g. The color of the call to action button.  or the info text to display.
// ! locale_id:1 key:ActionButtonVariant value:3
type CardReaderAttribute struct {
	// ! The local's are defined in POS TSA.
	LocaleId *int32 `protobuf:"varint,1,req,name=locale_id" json:"locale_id,omitempty"`
	// ! Attribute key.  e.g. "RegistrationQuestionText"
	Key *string `protobuf:"bytes,2,req,name=key" json:"key,omitempty"`
	// ! Attribute value.  e.g. "Have you registered for eReceipts?"
	Value            *string `protobuf:"bytes,3,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CardReaderAttribute) Reset()         { *m = CardReaderAttribute{} }
func (m *CardReaderAttribute) String() string { return proto.CompactTextString(m) }
func (*CardReaderAttribute) ProtoMessage()    {}

func (m *CardReaderAttribute) GetLocaleId() int32 {
	if m != nil && m.LocaleId != nil {
		return *m.LocaleId
	}
	return 0
}

func (m *CardReaderAttribute) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *CardReaderAttribute) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// ! A profile for the card reader.  We can use profiles to mix up the value proposition and themes.
type CardReaderProfile struct {
	// ! e.g. "SavePaperVariant2"
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// ! One profile is selected per transaction from a pool.  The
	// ! higher this number the more chance it has of beeing selected.
	FrequencyBias    *int32                 `protobuf:"varint,2,opt,name=frequency_bias,def=1" json:"frequency_bias,omitempty"`
	Attributes       []*CardReaderAttribute `protobuf:"bytes,3,rep,name=attributes" json:"attributes,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *CardReaderProfile) Reset()         { *m = CardReaderProfile{} }
func (m *CardReaderProfile) String() string { return proto.CompactTextString(m) }
func (*CardReaderProfile) ProtoMessage()    {}

const Default_CardReaderProfile_FrequencyBias int32 = 1

func (m *CardReaderProfile) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CardReaderProfile) GetFrequencyBias() int32 {
	if m != nil && m.FrequencyBias != nil {
		return *m.FrequencyBias
	}
	return Default_CardReaderProfile_FrequencyBias
}

func (m *CardReaderProfile) GetAttributes() []*CardReaderAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// ! Ask server for the latest card reader profiles
type RefreshCardReaderProfilesRequest struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *RefreshCardReaderProfilesRequest) Reset()         { *m = RefreshCardReaderProfilesRequest{} }
func (m *RefreshCardReaderProfilesRequest) String() string { return proto.CompactTextString(m) }
func (*RefreshCardReaderProfilesRequest) ProtoMessage()    {}

// ! The latests profiles
type RefreshCardReaderProfilesResponse struct {
	Profiles         []*CardReaderProfile `protobuf:"bytes,1,rep,name=profiles" json:"profiles,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *RefreshCardReaderProfilesResponse) Reset()         { *m = RefreshCardReaderProfilesResponse{} }
func (m *RefreshCardReaderProfilesResponse) String() string { return proto.CompactTextString(m) }
func (*RefreshCardReaderProfilesResponse) ProtoMessage()    {}

func (m *RefreshCardReaderProfilesResponse) GetProfiles() []*CardReaderProfile {
	if m != nil {
		return m.Profiles
	}
	return nil
}

// ! What is the state of a process (one of fep, uploader, dispatch).
type ProcessStatus struct {
	HealthStatus  *ProcessStatus_HealthStatus `protobuf:"varint,1,req,name=health_status,enum=eReceipts.server.service.ProcessStatus_HealthStatus" json:"health_status,omitempty"`
	UptimeSeconds *int64                      `protobuf:"varint,2,req,name=uptime_seconds" json:"uptime_seconds,omitempty"`
	// VMS kb
	MemUsageKb    *int32 `protobuf:"varint,3,req,name=mem_usage_kb" json:"mem_usage_kb,omitempty"`
	LogFileSizeKb *int32 `protobuf:"varint,4,req,name=log_file_size_kb" json:"log_file_size_kb,omitempty"`
	// ! How many errors have we encouted since the last time we've reported to the server?
	ErrorsSinceLastHeartbeat *int32 `protobuf:"varint,5,opt,name=errors_since_last_heartbeat" json:"errors_since_last_heartbeat,omitempty"`
	XXX_unrecognized         []byte `json:"-"`
}

func (m *ProcessStatus) Reset()         { *m = ProcessStatus{} }
func (m *ProcessStatus) String() string { return proto.CompactTextString(m) }
func (*ProcessStatus) ProtoMessage()    {}

func (m *ProcessStatus) GetHealthStatus() ProcessStatus_HealthStatus {
	if m != nil && m.HealthStatus != nil {
		return *m.HealthStatus
	}
	return ProcessStatus_UNKNOWN
}

func (m *ProcessStatus) GetUptimeSeconds() int64 {
	if m != nil && m.UptimeSeconds != nil {
		return *m.UptimeSeconds
	}
	return 0
}

func (m *ProcessStatus) GetMemUsageKb() int32 {
	if m != nil && m.MemUsageKb != nil {
		return *m.MemUsageKb
	}
	return 0
}

func (m *ProcessStatus) GetLogFileSizeKb() int32 {
	if m != nil && m.LogFileSizeKb != nil {
		return *m.LogFileSizeKb
	}
	return 0
}

func (m *ProcessStatus) GetErrorsSinceLastHeartbeat() int32 {
	if m != nil && m.ErrorsSinceLastHeartbeat != nil {
		return *m.ErrorsSinceLastHeartbeat
	}
	return 0
}

// ! We send up all the procss status and receive new configuration/actions
type HeartbeatRequest struct {
	FepStatus        *ProcessStatus `protobuf:"bytes,1,req,name=fep_status" json:"fep_status,omitempty"`
	UploaderStatus   *ProcessStatus `protobuf:"bytes,2,req,name=uploader_status" json:"uploader_status,omitempty"`
	DispatchStatus   *ProcessStatus `protobuf:"bytes,3,req,name=dispatch_status" json:"dispatch_status,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *HeartbeatRequest) Reset()         { *m = HeartbeatRequest{} }
func (m *HeartbeatRequest) String() string { return proto.CompactTextString(m) }
func (*HeartbeatRequest) ProtoMessage()    {}

func (m *HeartbeatRequest) GetFepStatus() *ProcessStatus {
	if m != nil {
		return m.FepStatus
	}
	return nil
}

func (m *HeartbeatRequest) GetUploaderStatus() *ProcessStatus {
	if m != nil {
		return m.UploaderStatus
	}
	return nil
}

func (m *HeartbeatRequest) GetDispatchStatus() *ProcessStatus {
	if m != nil {
		return m.DispatchStatus
	}
	return nil
}

// ! Actions and configuration.
type HeartbeatResponse struct {
	// ! Information about receipt throttling behavior
	CommsConfig *CommsConfig `protobuf:"bytes,1,req,name=comms_config" json:"comms_config,omitempty"`
	// ! If this is true, the SMART box should purge it's receipt
	// ! queue. This should be set transiently (it shouldn't be true
	// ! twice in a row)
	PurgeQueueNow *bool `protobuf:"varint,2,opt,name=purge_queue_now" json:"purge_queue_now,omitempty"`
	PurgeLogsNow  *bool `protobuf:"varint,3,opt,name=purge_logs_now" json:"purge_logs_now,omitempty"`
	// ! If true, the SMART server should restart the fep
	ForceRestartFep *bool `protobuf:"varint,4,opt,name=force_restart_fep" json:"force_restart_fep,omitempty"`
	// ! If true, the SMART server should restart the uploader
	ForceRestartUploader *bool `protobuf:"varint,5,opt,name=force_restart_uploader" json:"force_restart_uploader,omitempty"`
	// ! If true, the SMART server should restart the dispatch
	ForceRestartDispatch *bool `protobuf:"varint,6,opt,name=force_restart_dispatch" json:"force_restart_dispatch,omitempty"`
	UploadLogsNow        *bool `protobuf:"varint,7,opt,name=upload_logs_now" json:"upload_logs_now,omitempty"`
	// ! if greater than 0 the SMART server should upload n number of test
	// ! receipts (used to test that batching, throttling etc is
	// ! working
	UploadTestReceipts          *int32 `protobuf:"varint,8,opt,name=upload_test_receipts" json:"upload_test_receipts,omitempty"`
	RunLoopSleepMicroseconds    *int32 `protobuf:"varint,9,opt,name=run_loop_sleep_microseconds,def=1000" json:"run_loop_sleep_microseconds,omitempty"`
	HeartbeatIntervalModulo     *int32 `protobuf:"varint,10,opt,name=heartbeat_interval_modulo,def=50" json:"heartbeat_interval_modulo,omitempty"`
	SyncTemplatesIntervalModulo *int32 `protobuf:"varint,11,opt,name=sync_templates_interval_modulo,def=1500" json:"sync_templates_interval_modulo,omitempty"`
	// ! debug, warning, trace, error = "dwte" or "dw"
	// ! warning, trace, error = "wte"
	LoggingFlags *string `protobuf:"bytes,12,opt,name=logging_flags,def=dwte" json:"logging_flags,omitempty"`
	UrlDomain    *string `protobuf:"bytes,13,opt,name=url_domain,def=https://wlmt.co" json:"url_domain,omitempty"`
	// ! Do a syncTemplates call immediately
	SyncTemplatesNow *bool `protobuf:"varint,14,opt,name=sync_templates_now" json:"sync_templates_now,omitempty"`
	// ! Blow away the database and restart fep and uploader.  Fep will recreated DB.
	// ! Only used if we corrupt the DB somehow.
	NukeDbAndRestartFepAndUploader *bool `protobuf:"varint,15,opt,name=nuke_db_and_restart_fep_and_uploader" json:"nuke_db_and_restart_fep_and_uploader,omitempty"`
	// ! Nuke any log file that exceeds this size
	MaxLogFileSizeBytes                     *int32 `protobuf:"varint,16,opt,name=max_log_file_size_bytes,def=5242880" json:"max_log_file_size_bytes,omitempty"`
	RefreshCardReaderProfilesIntervalModulo *int32 `protobuf:"varint,17,opt,name=refresh_card_reader_profiles_interval_modulo,def=1500" json:"refresh_card_reader_profiles_interval_modulo,omitempty"`
	// ! Do a refreshCardReaderProfiles call immediately
	RefreshCardReaderProfilesNow *bool `protobuf:"varint,18,opt,name=refresh_card_reader_profiles_now" json:"refresh_card_reader_profiles_now,omitempty"`
	// ! Ask the controller for a set of static receipt images (header,
	// ! footer, survey)
	RefreshStaticImagesNow             *bool  `protobuf:"varint,19,opt,name=refresh_static_images_now" json:"refresh_static_images_now,omitempty"`
	RefreshVuduMarketingIntervalModulo *int32 `protobuf:"varint,20,opt,name=refresh_vudu_marketing_interval_modulo,def=100000" json:"refresh_vudu_marketing_interval_modulo,omitempty"`
	RefershVuduMarketingIntervalNow    *bool  `protobuf:"varint,21,opt,name=refersh_vudu_marketing_interval_now" json:"refersh_vudu_marketing_interval_now,omitempty"`
	XXX_unrecognized                   []byte `json:"-"`
}

func (m *HeartbeatResponse) Reset()         { *m = HeartbeatResponse{} }
func (m *HeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*HeartbeatResponse) ProtoMessage()    {}

const Default_HeartbeatResponse_RunLoopSleepMicroseconds int32 = 1000
const Default_HeartbeatResponse_HeartbeatIntervalModulo int32 = 50
const Default_HeartbeatResponse_SyncTemplatesIntervalModulo int32 = 1500
const Default_HeartbeatResponse_LoggingFlags string = "dwte"
const Default_HeartbeatResponse_UrlDomain string = "https://wlmt.co"
const Default_HeartbeatResponse_MaxLogFileSizeBytes int32 = 5242880
const Default_HeartbeatResponse_RefreshCardReaderProfilesIntervalModulo int32 = 1500
const Default_HeartbeatResponse_RefreshVuduMarketingIntervalModulo int32 = 100000

func (m *HeartbeatResponse) GetCommsConfig() *CommsConfig {
	if m != nil {
		return m.CommsConfig
	}
	return nil
}

func (m *HeartbeatResponse) GetPurgeQueueNow() bool {
	if m != nil && m.PurgeQueueNow != nil {
		return *m.PurgeQueueNow
	}
	return false
}

func (m *HeartbeatResponse) GetPurgeLogsNow() bool {
	if m != nil && m.PurgeLogsNow != nil {
		return *m.PurgeLogsNow
	}
	return false
}

func (m *HeartbeatResponse) GetForceRestartFep() bool {
	if m != nil && m.ForceRestartFep != nil {
		return *m.ForceRestartFep
	}
	return false
}

func (m *HeartbeatResponse) GetForceRestartUploader() bool {
	if m != nil && m.ForceRestartUploader != nil {
		return *m.ForceRestartUploader
	}
	return false
}

func (m *HeartbeatResponse) GetForceRestartDispatch() bool {
	if m != nil && m.ForceRestartDispatch != nil {
		return *m.ForceRestartDispatch
	}
	return false
}

func (m *HeartbeatResponse) GetUploadLogsNow() bool {
	if m != nil && m.UploadLogsNow != nil {
		return *m.UploadLogsNow
	}
	return false
}

func (m *HeartbeatResponse) GetUploadTestReceipts() int32 {
	if m != nil && m.UploadTestReceipts != nil {
		return *m.UploadTestReceipts
	}
	return 0
}

func (m *HeartbeatResponse) GetRunLoopSleepMicroseconds() int32 {
	if m != nil && m.RunLoopSleepMicroseconds != nil {
		return *m.RunLoopSleepMicroseconds
	}
	return Default_HeartbeatResponse_RunLoopSleepMicroseconds
}

func (m *HeartbeatResponse) GetHeartbeatIntervalModulo() int32 {
	if m != nil && m.HeartbeatIntervalModulo != nil {
		return *m.HeartbeatIntervalModulo
	}
	return Default_HeartbeatResponse_HeartbeatIntervalModulo
}

func (m *HeartbeatResponse) GetSyncTemplatesIntervalModulo() int32 {
	if m != nil && m.SyncTemplatesIntervalModulo != nil {
		return *m.SyncTemplatesIntervalModulo
	}
	return Default_HeartbeatResponse_SyncTemplatesIntervalModulo
}

func (m *HeartbeatResponse) GetLoggingFlags() string {
	if m != nil && m.LoggingFlags != nil {
		return *m.LoggingFlags
	}
	return Default_HeartbeatResponse_LoggingFlags
}

func (m *HeartbeatResponse) GetUrlDomain() string {
	if m != nil && m.UrlDomain != nil {
		return *m.UrlDomain
	}
	return Default_HeartbeatResponse_UrlDomain
}

func (m *HeartbeatResponse) GetSyncTemplatesNow() bool {
	if m != nil && m.SyncTemplatesNow != nil {
		return *m.SyncTemplatesNow
	}
	return false
}

func (m *HeartbeatResponse) GetNukeDbAndRestartFepAndUploader() bool {
	if m != nil && m.NukeDbAndRestartFepAndUploader != nil {
		return *m.NukeDbAndRestartFepAndUploader
	}
	return false
}

func (m *HeartbeatResponse) GetMaxLogFileSizeBytes() int32 {
	if m != nil && m.MaxLogFileSizeBytes != nil {
		return *m.MaxLogFileSizeBytes
	}
	return Default_HeartbeatResponse_MaxLogFileSizeBytes
}

func (m *HeartbeatResponse) GetRefreshCardReaderProfilesIntervalModulo() int32 {
	if m != nil && m.RefreshCardReaderProfilesIntervalModulo != nil {
		return *m.RefreshCardReaderProfilesIntervalModulo
	}
	return Default_HeartbeatResponse_RefreshCardReaderProfilesIntervalModulo
}

func (m *HeartbeatResponse) GetRefreshCardReaderProfilesNow() bool {
	if m != nil && m.RefreshCardReaderProfilesNow != nil {
		return *m.RefreshCardReaderProfilesNow
	}
	return false
}

func (m *HeartbeatResponse) GetRefreshStaticImagesNow() bool {
	if m != nil && m.RefreshStaticImagesNow != nil {
		return *m.RefreshStaticImagesNow
	}
	return false
}

func (m *HeartbeatResponse) GetRefreshVuduMarketingIntervalModulo() int32 {
	if m != nil && m.RefreshVuduMarketingIntervalModulo != nil {
		return *m.RefreshVuduMarketingIntervalModulo
	}
	return Default_HeartbeatResponse_RefreshVuduMarketingIntervalModulo
}

func (m *HeartbeatResponse) GetRefershVuduMarketingIntervalNow() bool {
	if m != nil && m.RefershVuduMarketingIntervalNow != nil {
		return *m.RefershVuduMarketingIntervalNow
	}
	return false
}

// ! The textural logs for all three processors on smart (Stored in
// ! /u/spool/02/eReceipts-fep.log, ... )
type UploadLogsRequest struct {
	FepLogs          *string `protobuf:"bytes,1,req,name=fep_logs" json:"fep_logs,omitempty"`
	UploaderLogs     *string `protobuf:"bytes,2,req,name=uploader_logs" json:"uploader_logs,omitempty"`
	DispatchLogs     *string `protobuf:"bytes,3,req,name=dispatch_logs" json:"dispatch_logs,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UploadLogsRequest) Reset()         { *m = UploadLogsRequest{} }
func (m *UploadLogsRequest) String() string { return proto.CompactTextString(m) }
func (*UploadLogsRequest) ProtoMessage()    {}

func (m *UploadLogsRequest) GetFepLogs() string {
	if m != nil && m.FepLogs != nil {
		return *m.FepLogs
	}
	return ""
}

func (m *UploadLogsRequest) GetUploaderLogs() string {
	if m != nil && m.UploaderLogs != nil {
		return *m.UploaderLogs
	}
	return ""
}

func (m *UploadLogsRequest) GetDispatchLogs() string {
	if m != nil && m.DispatchLogs != nil {
		return *m.DispatchLogs
	}
	return ""
}

// ! A flag to say whether we should delete our logs (the server has
// ! stored them safely).
type UploadLogsResponse struct {
	PurgeLogsNow     *bool  `protobuf:"varint,1,req,name=purge_logs_now" json:"purge_logs_now,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UploadLogsResponse) Reset()         { *m = UploadLogsResponse{} }
func (m *UploadLogsResponse) String() string { return proto.CompactTextString(m) }
func (*UploadLogsResponse) ProtoMessage()    {}

func (m *UploadLogsResponse) GetPurgeLogsNow() bool {
	if m != nil && m.PurgeLogsNow != nil {
		return *m.PurgeLogsNow
	}
	return false
}

// ! We'v captured either the cusotmer's phone number or a membership
// ! card.  This message can be sent multiple times per transaction if
// ! the customer changes their mind.
type LookupCustomerRequest struct {
	// ! Gathered from the CISAM database on the SMART server. Should
	// ! be either WMSC (Walmart Super Center) or SAMS (Sam's Club) or
	// ! WMGM (Walmart Greedy Manticore)
	BusinessType *string `protobuf:"bytes,1,req,name=business_type" json:"business_type,omitempty"`
	PhoneNumber  *string `protobuf:"bytes,2,opt,name=phone_number" json:"phone_number,omitempty"`
	// ! Sam's club membership number or any other Walmart subsidiary's
	// ! membership number
	MembershipNumber *string `protobuf:"bytes,3,opt,name=membership_number" json:"membership_number,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LookupCustomerRequest) Reset()         { *m = LookupCustomerRequest{} }
func (m *LookupCustomerRequest) String() string { return proto.CompactTextString(m) }
func (*LookupCustomerRequest) ProtoMessage()    {}

func (m *LookupCustomerRequest) GetBusinessType() string {
	if m != nil && m.BusinessType != nil {
		return *m.BusinessType
	}
	return ""
}

func (m *LookupCustomerRequest) GetPhoneNumber() string {
	if m != nil && m.PhoneNumber != nil {
		return *m.PhoneNumber
	}
	return ""
}

func (m *LookupCustomerRequest) GetMembershipNumber() string {
	if m != nil && m.MembershipNumber != nil {
		return *m.MembershipNumber
	}
	return ""
}

// ! Did we find the customer?  How do they want their receipt.
type LookupCustomerResponse struct {
	ReceiptBehaviour *LookupCustomerResponse_ReceiptBehaviour `protobuf:"varint,1,req,name=receipt_behaviour,enum=eReceipts.server.service.LookupCustomerResponse_ReceiptBehaviour" json:"receipt_behaviour,omitempty"`
	XXX_unrecognized []byte                                   `json:"-"`
}

func (m *LookupCustomerResponse) Reset()         { *m = LookupCustomerResponse{} }
func (m *LookupCustomerResponse) String() string { return proto.CompactTextString(m) }
func (*LookupCustomerResponse) ProtoMessage()    {}

func (m *LookupCustomerResponse) GetReceiptBehaviour() LookupCustomerResponse_ReceiptBehaviour {
	if m != nil && m.ReceiptBehaviour != nil {
		return *m.ReceiptBehaviour
	}
	return LookupCustomerResponse_CUSTOMER_IDENTITY_NOT_FOUND
}

// ! Either tc_number or {register_id, register_transaction_number} provided.
type TrxVoidedRequest struct {
	// ! Walmart's 20-25 digit TC Number.
	TcNumber *string `protobuf:"bytes,1,opt,name=tc_number" json:"tc_number,omitempty"`
	// ! terminal/reigster number. (TE#)
	RegisterId *string `protobuf:"bytes,2,opt,name=register_id" json:"register_id,omitempty"`
	// ! The sequential per reigster transaction number (TR#)
	RegisterTransactionNumber *string `protobuf:"bytes,3,opt,name=register_transaction_number" json:"register_transaction_number,omitempty"`
	XXX_unrecognized          []byte  `json:"-"`
}

func (m *TrxVoidedRequest) Reset()         { *m = TrxVoidedRequest{} }
func (m *TrxVoidedRequest) String() string { return proto.CompactTextString(m) }
func (*TrxVoidedRequest) ProtoMessage()    {}

func (m *TrxVoidedRequest) GetTcNumber() string {
	if m != nil && m.TcNumber != nil {
		return *m.TcNumber
	}
	return ""
}

func (m *TrxVoidedRequest) GetRegisterId() string {
	if m != nil && m.RegisterId != nil {
		return *m.RegisterId
	}
	return ""
}

func (m *TrxVoidedRequest) GetRegisterTransactionNumber() string {
	if m != nil && m.RegisterTransactionNumber != nil {
		return *m.RegisterTransactionNumber
	}
	return ""
}

// ! A response is implicit success.
type TrxVoidedResponse struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *TrxVoidedResponse) Reset()         { *m = TrxVoidedResponse{} }
func (m *TrxVoidedResponse) String() string { return proto.CompactTextString(m) }
func (*TrxVoidedResponse) ProtoMessage()    {}

// ! The controller has a set of images for headers, footers, surveys
// ! that get saved on receipt printers. We don't want to send the
// ! images up with the receipts because it is a waste of bandwidth.
// ! We just send the MD5 sums that should match one of these images.
// ! We periodically ask the controller for its set and give them to
// ! the server.
type StaticImageDataRequest struct {
	PngImages        [][]byte `protobuf:"bytes,1,rep,name=png_images" json:"png_images,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *StaticImageDataRequest) Reset()         { *m = StaticImageDataRequest{} }
func (m *StaticImageDataRequest) String() string { return proto.CompactTextString(m) }
func (*StaticImageDataRequest) ProtoMessage()    {}

func (m *StaticImageDataRequest) GetPngImages() [][]byte {
	if m != nil {
		return m.PngImages
	}
	return nil
}

// ! Implicit success.
type StaticImageDataResponse struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *StaticImageDataResponse) Reset()         { *m = StaticImageDataResponse{} }
func (m *StaticImageDataResponse) String() string { return proto.CompactTextString(m) }
func (*StaticImageDataResponse) ProtoMessage()    {}

// ! Vudu get to put have some marketing specific to the matched DVD
// ! upc for encouraging people to use digitial redemption.
type VuduMarketingReceiptLine struct {
	// ! A line of text.  Server should make sure it will fit on the
	// ! receipt.  Especially important if this is double size font.
	Text *string `protobuf:"bytes,1,req,name=text" json:"text,omitempty"`
	// ! Do we use 2x font?
	IsDoubleSize     *bool  `protobuf:"varint,2,opt,name=is_double_size,def=0" json:"is_double_size,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *VuduMarketingReceiptLine) Reset()         { *m = VuduMarketingReceiptLine{} }
func (m *VuduMarketingReceiptLine) String() string { return proto.CompactTextString(m) }
func (*VuduMarketingReceiptLine) ProtoMessage()    {}

const Default_VuduMarketingReceiptLine_IsDoubleSize bool = false

func (m *VuduMarketingReceiptLine) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *VuduMarketingReceiptLine) GetIsDoubleSize() bool {
	if m != nil && m.IsDoubleSize != nil {
		return *m.IsDoubleSize
	}
	return Default_VuduMarketingReceiptLine_IsDoubleSize
}

// ! A DVD product that is setup for digital redemption.  If a customer
// ! purchases a product that matches this then we print the vudu
// ! static image on the receipt and any per item text above and below
// ! that image.
type VuduRedeemableProduct struct {
	// ! We don't want to be in the business of sanitising data.  Vudu
	// ! are responsible for UPC massage.
	UpcAsOnReceipt *string `protobuf:"bytes,1,req,name=upc_as_on_receipt" json:"upc_as_on_receipt,omitempty"`
	// ! Lines to print above the Vudu static advert image.
	LinesAboveImage []*VuduMarketingReceiptLine `protobuf:"bytes,2,rep,name=lines_above_image" json:"lines_above_image,omitempty"`
	// ! Lines to print below the Vudu static advert image.
	LinesBelowImage  []*VuduMarketingReceiptLine `protobuf:"bytes,3,rep,name=lines_below_image" json:"lines_below_image,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *VuduRedeemableProduct) Reset()         { *m = VuduRedeemableProduct{} }
func (m *VuduRedeemableProduct) String() string { return proto.CompactTextString(m) }
func (*VuduRedeemableProduct) ProtoMessage()    {}

func (m *VuduRedeemableProduct) GetUpcAsOnReceipt() string {
	if m != nil && m.UpcAsOnReceipt != nil {
		return *m.UpcAsOnReceipt
	}
	return ""
}

func (m *VuduRedeemableProduct) GetLinesAboveImage() []*VuduMarketingReceiptLine {
	if m != nil {
		return m.LinesAboveImage
	}
	return nil
}

func (m *VuduRedeemableProduct) GetLinesBelowImage() []*VuduMarketingReceiptLine {
	if m != nil {
		return m.LinesBelowImage
	}
	return nil
}

// ! Get a new data cut of Vudu stuff.
type RefreshVuduMarketingRequest struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *RefreshVuduMarketingRequest) Reset()         { *m = RefreshVuduMarketingRequest{} }
func (m *RefreshVuduMarketingRequest) String() string { return proto.CompactTextString(m) }
func (*RefreshVuduMarketingRequest) ProtoMessage()    {}

// ! We can have a pool of Vudu marketing images to pick from at the
// ! start of each transaction.  We save that image onto the receipt
// ! printer for fast printing.
type MarketingImage struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	PngImage         []byte  `protobuf:"bytes,2,req,name=png_image" json:"png_image,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MarketingImage) Reset()         { *m = MarketingImage{} }
func (m *MarketingImage) String() string { return proto.CompactTextString(m) }
func (*MarketingImage) ProtoMessage()    {}

func (m *MarketingImage) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *MarketingImage) GetPngImage() []byte {
	if m != nil {
		return m.PngImage
	}
	return nil
}

// ! The set of redeemable products as well as the set of marketing
// ! images to pick from at the start of the transaction.
type RefreshVuduMarketingResponse struct {
	Products []*VuduRedeemableProduct `protobuf:"bytes,1,rep,name=products" json:"products,omitempty"`
	// If more than one then image selected at random.
	PngMarketingImages []*MarketingImage `protobuf:"bytes,2,rep,name=png_marketing_images" json:"png_marketing_images,omitempty"`
	XXX_unrecognized   []byte            `json:"-"`
}

func (m *RefreshVuduMarketingResponse) Reset()         { *m = RefreshVuduMarketingResponse{} }
func (m *RefreshVuduMarketingResponse) String() string { return proto.CompactTextString(m) }
func (*RefreshVuduMarketingResponse) ProtoMessage()    {}

func (m *RefreshVuduMarketingResponse) GetProducts() []*VuduRedeemableProduct {
	if m != nil {
		return m.Products
	}
	return nil
}

func (m *RefreshVuduMarketingResponse) GetPngMarketingImages() []*MarketingImage {
	if m != nil {
		return m.PngMarketingImages
	}
	return nil
}

type SiteToStoreCheckinRequest struct {
	DataDump         *string `protobuf:"bytes,1,req,name=data_dump" json:"data_dump,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SiteToStoreCheckinRequest) Reset()         { *m = SiteToStoreCheckinRequest{} }
func (m *SiteToStoreCheckinRequest) String() string { return proto.CompactTextString(m) }
func (*SiteToStoreCheckinRequest) ProtoMessage()    {}

func (m *SiteToStoreCheckinRequest) GetDataDump() string {
	if m != nil && m.DataDump != nil {
		return *m.DataDump
	}
	return ""
}

type SiteToStoreCheckinResponse struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *SiteToStoreCheckinResponse) Reset()         { *m = SiteToStoreCheckinResponse{} }
func (m *SiteToStoreCheckinResponse) String() string { return proto.CompactTextString(m) }
func (*SiteToStoreCheckinResponse) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("eReceipts.server.service.CommsConfig_OperationMode", CommsConfig_OperationMode_name, CommsConfig_OperationMode_value)
	proto.RegisterEnum("eReceipts.server.service.ProcessStatus_HealthStatus", ProcessStatus_HealthStatus_name, ProcessStatus_HealthStatus_value)
	proto.RegisterEnum("eReceipts.server.service.LookupCustomerResponse_ReceiptBehaviour", LookupCustomerResponse_ReceiptBehaviour_name, LookupCustomerResponse_ReceiptBehaviour_value)
}
